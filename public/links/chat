<div style="display: flex; flex-direction: column; height: 100vh; font-family: sans-serif;">
    <header style="padding: 1rem; background-color: #f5f5f5; border-bottom: 1px solid #ddd;">
        <div style="display: flex; gap: 1rem; flex-wrap: wrap;">
            <label style="display: flex; flex-direction: column;">
                Model Name
                <input type="text" style="padding: 4px;">
            </label>
            <label style="display: flex; flex-direction: column;">
                Model Host
                <input type="text" style="padding: 4px;">
            </label>
            <label style="display: flex; flex-direction: column;">
                API Key
                <input type="password" style="padding: 4px;">
            </label>
        </div>
    </header>

    <div style="flex: 1; overflow-y: auto; padding: 1rem; background-color: #fff;">
        <!-- Messages Area -->
    </div>

    <footer style="padding: 1rem; background-color: #f5f5f5; border-top: 1px solid #ddd; display: flex; gap: 10px;">
        <textarea style="flex: 1; resize: vertical; padding: 0.5rem; min-height: 50px;"></textarea>
        <button type="submit" style="padding: 0 1.5rem; cursor: pointer;">Submit</button>
    </footer>
</div><script>
const inputs = document.querySelectorAll('header input');
if (inputs.length >= 3) {
    inputs[0].value = localStorage.getItem('m') || '';
    inputs[1].value = localStorage.getItem('h') || '';
    inputs[2].value = localStorage.getItem('k') || '';
}
</script><script>
window.chatPlugins = {
    logger: {
        callback: (text, fullChat) => {
            console.log("Transformed Prompt:", text);
            return text;
        }
    }
};

const D = document,
    Q = s => D.querySelector(s),
    area = Q('div[style*="overflow-y: auto"]'),
    txt = Q('footer textarea'),
    btn = Q('footer button');

D.querySelectorAll('header input').forEach((el, i) => 
    el.oninput = () => localStorage.setItem(['m','h','k'][i], el.value)
);

const handleChat = async () => {
    const val = txt.value.trim();
    if (!val) return;
    txt.value = "";

    const userDiv = D.createElement('div');
    userDiv.style = "padding:10px;background:#f5f5f5;margin:5px 0;border-radius:5px;";
    userDiv.innerText = val;
    area.appendChild(userDiv);

    const aiDiv = D.createElement('div');
    aiDiv.style = "padding:10px;white-space:pre-wrap;margin:5px 0;";
    area.appendChild(aiDiv);

    let prompt = area.innerText;
    Object.values(window.chatPlugins).forEach(p => {
        if(p.callback) prompt = p.callback(prompt, area.innerText);
    });

    const m = localStorage.getItem('m'),
        h = localStorage.getItem('h'),
        k = localStorage.getItem('k'),
        isG = h === 'google';

    const url = isG ? 
        `https://generativelanguage.googleapis.com/v1beta/models/${m}:streamGenerateContent?key=${k}` : h;
    
    const headers = { "Content-Type": "application/json" };
    if (!isG && k) headers.Authorization = `Bearer ${k}`;

    const body = JSON.stringify(isG ? 
        { contents: [{ parts: [{ text: prompt }] }] } : 
        { model: m, stream: true, messages: [{ role: "user", content: prompt }] }
    );

    try {
        const res = await fetch(url, { method: "POST", headers, body });
        const reader = res.body.getReader();
        const decoder = new TextDecoder();
        let buffer = "", gIdx = 0;

        while (true) {
            const { done, value } = await reader.read();
            if (done) break;
            buffer += decoder.decode(value, { stream: true });

            if (isG) {
                const regex = /"text":\s*"((?:[^"\\]|\\.)*)"/g;
                regex.lastIndex = gIdx;
                let match;
                while ((match = regex.exec(buffer)) !== null) {
                    aiDiv.innerText += JSON.parse(`"${match[1]}"`);
                    gIdx = regex.lastIndex;
                }
            } else {
                const lines = buffer.split('\n');
                buffer = lines.pop();
                for (const line of lines) {
                    if (line.trim().startsWith("data:") && !line.includes("[DONE]")) {
                        try {
                            const json = JSON.parse(line.slice(5));
                            aiDiv.innerText += json.choices?.[0]?.delta?.content || json.message?.content || "";
                        } catch (e) {}
                    }
                }
            }
        }
    } catch (e) {
        aiDiv.innerText += "\nError: " + e.message;
    }
};

btn.onclick = handleChat;
txt.onkeydown = e => {
    if (e.ctrlKey && e.key === "Enter") {
        e.preventDefault();
        handleChat();
    }
};
</script><script>
window.chatPlugins.contextExpander = {
    callback: async (prompt) => {
        const regex = /\[\[(.*?)\]\]/g;
        const matches = [...prompt.matchAll(regex)];
        const unique = [...new Set(matches.map(m => m[1]))];
        const replacements = {};

        await Promise.all(unique.map(async (link) => {
            let table = window.DB;
            let key = link;
            if (link.includes('#')) {
                const parts = link.split('#');
                if (parts[0]) table = parts[0];
                key = parts[1];
            }
            try {
                const ctx = await read(key, table);
                if (ctx) {
                    console.log(`Linked: ${table}#${key}`, ctx);
                    replacements[link] = `<context file="${table}#${key}">${ctx}</context>`;
                }
            } catch (e) {}
        }));

        return prompt.replace(regex, (m, p1) => replacements[p1] || m);
    }
};

// Patch runner to support async plugins
const _b = document.querySelector('footer button'),
      _t = document.querySelector('footer textarea'),
      _a = document.querySelector('div[style*="overflow-y: auto"]');

_b.onclick = async () => {
    const val = _t.value.trim();
    if (!val) return;
    _t.value = "";

    const userDiv = document.createElement('div');
    userDiv.style = "padding:10px;background:#f5f5f5;margin:5px 0;border-radius:5px;";
    userDiv.innerText = val;
    _a.appendChild(userDiv);

    const aiDiv = document.createElement('div');
    aiDiv.style = "padding:10px;white-space:pre-wrap;margin:5px 0;";
    _a.appendChild(aiDiv);

    let prompt = _a.innerText;
    
    // Async plugin execution
    for (const p of Object.values(window.chatPlugins)) {
        if (p.callback) prompt = await p.callback(prompt, _a.innerText);
    }

    const m = localStorage.getItem('m'),
          h = localStorage.getItem('h'),
          k = localStorage.getItem('k'),
          isG = h === 'google';

    const url = isG ? 
        `https://generativelanguage.googleapis.com/v1beta/models/${m}:streamGenerateContent?key=${k}` : h;
    
    const headers = { "Content-Type": "application/json" };
    if (!isG && k) headers.Authorization = `Bearer ${k}`;

    const body = JSON.stringify(isG ? 
        { contents: [{ parts: [{ text: prompt }] }] } : 
        { model: m, stream: true, messages: [{ role: "user", content: prompt }] }
    );

    try {
        const res = await fetch(url, { method: "POST", headers, body });
        const reader = res.body.getReader();
        const decoder = new TextDecoder();
        let buffer = "", gIdx = 0;

        while (true) {
            const { done, value } = await reader.read();
            if (done) break;
            buffer += decoder.decode(value, { stream: true });

            if (isG) {
                const regex = /"text":\s*"((?:[^"\\]|\\.)*)"/g;
                regex.lastIndex = gIdx;
                let match;
                while ((match = regex.exec(buffer)) !== null) {
                    aiDiv.innerText += JSON.parse(`"${match[1]}"`);
                    gIdx = regex.lastIndex;
                }
            } else {
                const lines = buffer.split('\n');
                buffer = lines.pop();
                for (const line of lines) {
                    if (line.trim().startsWith("data:") && !line.includes("[DONE]")) {
                        try {
                            const json = JSON.parse(line.slice(5));
                            aiDiv.innerText += json.choices?.[0]?.delta?.content || json.message?.content || "";
                        } catch (e) {}
                    }
                }
            }
        }
    } catch (e) {
        aiDiv.innerText += "\nError: " + e.message;
    }
};

_t.onkeydown = e => {
    if (e.ctrlKey && e.key === "Enter") {
        e.preventDefault();
        _b.onclick();
    }
};
</script>