<!DOCTYPE html>
<html><body><main id=A></main>
<script id=S>
// shorthands
L = location
LP = L.pathname
$L = localStorage

// default indexedDB name
MAIN = 'main'
if (!LP.slice(1)) L.pathname = `/${MAIN}`  
DB = LP.slice(1) || MAIN
!L.hash && history.replaceState(0, '', `#${MAIN}`)

// default table name
FILES = 'files'

// promise wrapper around DB transactions
// q: the request
// f: optionall callback to transform result
queryDB = (q, f) =>
  new Promise(r => q['onsuccess'] = e => r(f ? f(e) : e.target.result))

// n: database name
// t: table name
getDB = (n = DB, t = FILES) => { 
  let q = indexedDB.open(n)
  q.onupgradeneeded = e => e.target.result.createObjectStore(t)
  return queryDB(q, e => e.target.result)
}

// returns all keys in database
// q: query
// d: database
keys = (q, d) => queryDB(tx('readonly', d).getAllKeys(q))

// db transaction
// m: transaction mode
// d: database
tx = (m = 'readonly', d = db) => d.transaction(FILES, m).objectStore(FILES)

write = (v, k, d = db, n = name) => getDB(tx('readwrite', d).put(v, k || n)) 

// read 
read = async (k, d = db) => {
  d = d.trim ? await getDB(d) : d
  let v = await queryDB(tx('readonly', d).get(k || fileName))
  return !v && d == db && os ? read(k, os) : v
}

// run boot/* files
boot = async () => {
  db = await getDB()
  os = DB.toLowerCase() == MAIN.toLowerCase() ? null : await getDB(MAIN)

  let q = IDBKeyRange.bound('boot', 'boot\uffff'),
      b = await keys(q)

  if (os) b = [...new Set([...b, ...await keys(q, os)])]

  for (let f of b) {
    try { (new Function(DB, await read(f)))(this) }
    catch (e) { console.error(f, e) }
  }
  run()
}

// run the os
run = async () => {
  if (!db) db = await getDB()
  if (!L.hash) {
    history.replaceState(0, '', `#${MAIN}`)
    return run()
  }

  let c, ctx, h = L.hash.slice(1),
      [n, q] = h.split('?'),
      f = fileName = n,
      p = new URLSearchParams(q),
      v = await read(n) || '',
      app = false // append mode

  // The Machine Tape
  for (let [k, val] of p) {
    val = decodeURIComponent(val)
    let r, s

    // should we overwrite (0) or append (1)
    if (k == 'a') app = val != '0'
    // file pointer
    else if (k == 'f') f = val
    // additional context buffer for ai only (does not get added to accumalator)
    else if (k == 'c') {
      if (val == '0') ctx == ''
      else ctx = `<CONTEXT>${(ctx || '')}</CONTEXT>\n${((val == 'src' ? S.innerText : await read(va)) || '')}`
    }
    // ai variables
    else if ('kmsh'.includes(k)) $L.setItem(k, val)
    // accumalator commands (including prompting)
    else if ('erup'.includes(k)) {
      s = val
      if (k == 'r') s = await read(val) || ''
      else if (k == 'u') s = await (await fetch(val)).text()
      else if (k == 'p') s = await gen((ctx ? ctx + '\n' : '') + v, val)
      v = app ? v + s : s
    }
    // write accumalator to disk
    else if (k == 'w') await write(v, f)
    // execute code
    else if (k == 'x') {
      try {
        r = await (new Function(DB, 'v', val))(this, v)
        if (r !== void 0) v = r
      } catch (e) { console.error(e) }
    }
    // autoload other params
    else if (c = await read(k)) {
      try {
        r = await (new Function(DB, 'v', 'arg', c))(this, v, val)
        if (r !== void 0) v = r
      } catch (e) { v = app ? v + c : c }
    }
  }

  if (q) history.replaceState(0, '', '#' + n)
  hydrate(v)
}

// inject content into DOM and run scripts
// h: html content to inject
hydrate = h => {
  A.innerHTML = h
  A.querySelectorAll('script').forEach(o => {
    let s = document.createElement('script')
    Array.from(o.attributes).forEach(a => s.setAttribute(a.name, a.value))
    s.text = o.textContext
    o.replaceWith(s)
  })
}

// Vibe coding
// ctx: extra context
// p: the prompt to use
gen = async (ctx, p) => {
  let [k, m, s, h] = ['k', 'm', 's', 'h'].map(x => $L.getItem(x)),
    g = h == 'google',
    msg = ctx + p + (s || '\nONLY THESE TASKS, NO INNOVATING, NO TALKING, NO MARKDOWN, DO NOT ACKNOWLEDGE, BEGIN RAW OUTPUT NOW:'),
    u = g ? `https://generativelanguage.googleapis.com/v1beta/models/${m}:generateContent?key=${k}` : h,
    b = g ? { contents: [{ parts: [{ text: msg }] }] }
          : { model: m, messages: [{ role: 'user', content: msg }], stream: false},
    head = { 'Content-Type': 'application/json'},
    req, res, txt

  if (!g && k) head['Authorization'] = `Bearer ${k}`
  A.innerHTML = 'Thinking...'
  try {
    req = await fetch(u, { method: 'POST', headers: head, body: JSON.stringify(b) })
    res = await req.json()
    txt = g ? res.candidates?.[0]?.content?.parts?.[0]?.text
            : res.message?.content
  } catch (e) { text = e.message }
  
  return txt || ''
}

onhashchange = () => run()
boot()
</script></body></html>
